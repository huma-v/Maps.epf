
#Область Геоданные

Функция ПолучитьКоординатыПоIP() Экспорт
	// ВНИМАНИЕ!!!
	// ipwho.is не использование в коммерческих условиях,
	// Если эта обработка будет использоваться в коммерческих условиях, требуется:
	// - Купить коммерческую подписку ipwho.is
	// - ИЛИ Переписать эту функцию на использование другого сервиса
	// - ИЛИ Закоментировать вызов этой функции в Форма.ПолучитьОбластьПросмотраПоУмолчанию()
	лЗащСоед = Новый ЗащищенноеСоединениеOpenSSL(, Новый СертификатыУдостоверяющихЦентровОС());
	лСоединение = Новый HTTPСоединение("ipwho.is", , , , , , лЗащСоед);
	
	лЗапрос = Новый HTTPЗапрос("");
	
	лОтвет = лСоединение.Получить(лЗапрос);
	лТекстОтвета = лОтвет.ПолучитьТелоКакСтроку();
	лСтруктураОтвета = СтруктураИзJSON(лТекстОтвета);
	
	Возврат Новый Структура("Широта, Долгота", лСтруктураОтвета.latitude, лСтруктураОтвета.longitude);
КонецФункции


Функция Геокодинг(Адрес, Центр, Границы) Экспорт
	лТабРезультата = Новый ТаблицаЗначений;
	лТабРезультата.Колонки.Добавить("Адрес", Новый ОписаниеТипов("Строка")); // Адрес, "нормализованый" сервисом геокодинга
	лТабРезультата.Колонки.Добавить("Широта", Новый ОписаниеТипов("Число"));
	лТабРезультата.Колонки.Добавить("Долгота", Новый ОписаниеТипов("Число"));
	лТабРезультата.Колонки.Добавить("Оценка", Новый ОписаниеТипов("Число")); // Если было возвращено несколько адресов, предочтительней тот что имеет высшую оценку
	
	лРегионПоиска = XMLСтрока(Границы.СевероЗапад.Долгота) + "," + XMLСтрока(Границы.СевероЗапад.Широта) + "," + XMLСтрока(Границы.ЮгоВосток.Долгота) + "," + XMLСтрока(Границы.ЮгоВосток.Широта);
	лПараметры = Новый Структура("q, countrycodes, viewbox", Адрес, "UA", лРегионПоиска);
	лРезультат = ЗапросNomitanim("search", лПараметры);
	
	Для Каждого лТекРезультат Из лРезультат Цикл
		лШирота = Число(лТекРезультат["lat"]);
		лДолгота = Число(лТекРезультат["lon"]);
		
		Если лДолгота < Границы.СевероЗапад.Долгота ИЛИ лДолгота > Границы.ЮгоВосток.Долгота ИЛИ лШирота > Границы.СевероЗапад.Широта ИЛИ лШирота < Границы.ЮгоВосток.Широта Тогда
			Продолжить;
		КонецЕсли;
		
		лНов = лТабРезультата.Добавить();
		лНов.Адрес = лТекРезультат["display_name"];
		лНов.Широта = лШирота;
		лНов.Долгота = лДолгота;
		лНов.Оценка = лТекРезультат["importance"];
	КонецЦикла;
	
	лТабРезультата.Сортировать("Оценка УБЫВ");
	
	Возврат лТабРезультата;
КонецФункции


Функция ОбратныйГеокодинг(Широта, Долгота) Экспорт
	лПараметры = Новый Структура("lat, lon", XMLСтрока(Широта), XMLСтрока(Долгота));
	лРезультат = ЗапросNomitanim("reverse", лПараметры)["address"];
	
	лОбласть = лРезультат["state"];
	лНасПункт = ?(ЗначениеЗаполнено(лРезультат["village"]), лРезультат["village"], ?(ЗначениеЗаполнено(лРезультат["town"]), лРезультат["town"], лРезультат["city"]));
	лУлица = лРезультат["road"];
	лНомер = лРезультат["house_number"];
	лКомментарий = "";
	Для Каждого лТекПоле Из РазбитьСтроку("amenity,shop,man_made,leisure", ",") Цикл
		Если ЗначениеЗаполнено(лРезультат[лТекПоле]) Тогда
			лКомментарий = лРезультат[лТекПоле];
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	лАдрес = Строка(лОбласть);
	Если ЗначениеЗаполнено(лНасПункт) Тогда
		лАдрес = лАдрес + ?(НЕ ПустаяСтрока(лАдрес), ", ", "") + лНасПункт;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(лУлица) Тогда
		лАдрес = лАдрес + ?(НЕ ПустаяСтрока(лАдрес), ", ", "") + лУлица;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(лНомер) Тогда
		лАдрес = лАдрес + ?(НЕ ПустаяСтрока(лАдрес), " ", "") + лНомер;
	ИначеЕсли ЗначениеЗаполнено(лКомментарий) Тогда
		лАдрес = лАдрес + ?(НЕ ПустаяСтрока(лАдрес), ", ", "") + лКомментарий;
	КонецЕсли;
	
	Возврат лАдрес;
КонецФункции


Функция РассчитатьМаршрут(ПутевыеТочки, Аннотации = Неопределено) Экспорт
	лРезультат = ЗапросOSRM("route", ПутевыеТочки, Новый Структура("geometries, steps", "geojson", "true"));
	
	лОтрезки = Новый Массив;
	Для Каждого лТекМаршрут Из лРезультат.routes Цикл
		Для Каждого лТекОтрезок Из лТекМаршрут.legs Цикл
			лЛоманая = Новый Массив;
			лПредКоорд = Неопределено;
			Для Каждого лТекШаг Из лТекОтрезок.steps Цикл
				Для Каждого лТекКоорд Из лТекШаг.geometry.coordinates Цикл
					Если лПредКоорд = Неопределено ИЛИ лПредКоорд.Широта <> лТекКоорд[1] ИЛИ лПредКоорд.Долгота <> лТекКоорд[0] Тогда
						лПредКоорд = Новый Структура("Широта, Долгота", лТекКоорд[1], лТекКоорд[0]);
						лЛоманая.Добавить(лПредКоорд);
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
			лОтрезки.Добавить(Новый Структура("Точки, Расстояние, Время", лЛоманая, лТекОтрезок.distance, лТекОтрезок.duration));
		КонецЦикла;
		Прервать;
	КонецЦикла;
	
	Возврат лОтрезки;
КонецФункции


Функция ОптимизироватьПорядокОбъезда(ПутевыеТочки) Экспорт
	лПараметры = Новый Структура;
	лПараметры.Вставить("roundtrip", "false");
	лПараметры.Вставить("source", "first");
	лПараметры.Вставить("destination", "last");
	
	лРезультат = ЗапросOSRM("trip", ПутевыеТочки, лПараметры);
	
	лИндексы = Новый Массив(лРезультат.waypoints.Количество());
	Для лИд = 0 По лРезультат.waypoints.Количество() - 1 Цикл
		лИндексы[лРезультат.waypoints[лИд].waypoint_index] = лИд;
	КонецЦикла;
	
	Возврат лИндексы;
КонецФункции


#Область ОберткиНадAPI

Функция ЗапросNomitanim(Знач Ресурс, Параметры = Неопределено)
	лПараметры = Новый Соответствие;
	лПараметры.Вставить("format", "json");
	лПараметры.Вставить("accept-language", НСтр("ru = 'ru'; uk = 'uk'"));
	
	Если Параметры <> Неопределено Тогда
		Для Каждого лТекКЗ Из Параметры Цикл
			лПараметры.Вставить(лТекКЗ.Ключ, лТекКЗ.Значение);
		КонецЦикла;
	КонецЕсли;
		
	// Заменить перед внедрением в production на self-hosted сервер
	лСоедSSL = Новый ЗащищенноеСоединениеOpenSSL(, Новый СертификатыУдостоверяющихЦентровОС);
	лСоедHTTPS = Новый HTTPСоединение("nominatim.openstreetmap.org", , , , , 10, лСоедSSL);
	
	Если лПараметры.Количество() <> 0 Тогда
		лФрагментыПараметров = Новый Массив;
		Для Каждого лТекКЗ Из лПараметры Цикл
			лФрагментыПараметров.Добавить(
				КодироватьСтроку(лТекКЗ.Ключ, СпособКодированияСтроки.КодировкаURL) + "=" + КодироватьСтроку(лТекКЗ.Значение, СпособКодированияСтроки.КодировкаURL))
		КонецЦикла;
		Ресурс = Ресурс + "?" + СоединитьСтроку(лФрагментыПараметров, "&");
	КонецЕсли;
	лЗапрос = Новый HTTPЗапрос(Ресурс);
	
	лОтвет = лСоедHTTPS.Получить(лЗапрос);
	Если лОтвет.КодСостояния <> 200 Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка при обращении к API Nominatim!'; uk = 'Помилка при звернені до API Nominatim!'");
	КонецЕсли;
	
	лЧтениеJSON = Новый ЧтениеJSON;
	лЧтениеJSON.ОткрытьПоток(лОтвет.ПолучитьТелоКакПоток());
	
	лРезультат = ПрочитатьJSON(лЧтениеJSON, Истина);
	
	Если ТипЗнч(лРезультат) = Тип("Соответствие") И лРезультат["error"] <> Неопределено Тогда
		ВызватьИсключение лРезультат["error"];
	КонецЕсли;
	
	Возврат лРезультат;
КонецФункции


Функция ЗапросOSRM(Служба, Координаты, Параметры = Неопределено)
	лПараметры = Новый Структура;
	Если Параметры <> Неопределено Тогда
		Для Каждого лТекКЗ Из Параметры Цикл
			лПараметры.Вставить(лТекКЗ.Ключ, лТекКЗ.Значение);
		КонецЦикла;
	КонецЕсли;
	
	// Заменить перед внедрением в production на self-hosted сервер
	лСоедSSL = Новый ЗащищенноеСоединениеOpenSSL(, Новый СертификатыУдостоверяющихЦентровОС);
	лСоедHTTPS = Новый HTTPСоединение("router.project-osrm.org", , , , , 10, лСоедSSL);
	
	лФрагментыКоординат = Новый Массив;
	Для Каждого лТекКоордината Из Координаты Цикл
		лФрагментыКоординат.Добавить(XMLСтрока(лТекКоордината.Долгота) + "," + XMLСтрока(лТекКоордината.Широта));
	КонецЦикла;
	
	лРесурс = Служба + "/v1/driving/" + СоединитьСтроку(лФрагментыКоординат, ";");
	Если лПараметры.Количество() <> 0 Тогда
		лФрагментыПараметров = Новый Массив;
		Для Каждого лТекКЗ Из лПараметры Цикл
			лФрагментыПараметров.Добавить(
				КодироватьСтроку(лТекКЗ.Ключ, СпособКодированияСтроки.КодировкаURL) + "=" + КодироватьСтроку(лТекКЗ.Значение, СпособКодированияСтроки.КодировкаURL))
		КонецЦикла;
		лРесурс = лРесурс + "?" + СоединитьСтроку(лФрагментыПараметров, "&");
	КонецЕсли;
	лЗапрос = Новый HTTPЗапрос(лРесурс);
	
	лОтвет = лСоедHTTPS.Получить(лЗапрос);
	Если лОтвет.КодСостояния <> 200 Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка при обращении к API OSRM!'; uk = 'Помилка при зверненні до API OSRM!'");
	КонецЕсли;
	
	лЧтениеJSON = Новый ЧтениеJSON;
	лЧтениеJSON.ОткрытьПоток(лОтвет.ПолучитьТелоКакПоток());
	
	лРезультат = ПрочитатьJSON(лЧтениеJSON);
	Если лРезультат.code <> "Ok" Тогда
		ВызватьИсключение лРезультат.code;
	КонецЕсли;
	
	Возврат лРезультат;
КонецФункции

#КонецОбласти

#КонецОбласти


#Область УниверсальныеМеханизмы

Функция JSONИзСтруктуры(Структура, ПараметрыЗаписиJSON = Неопределено) Экспорт
	лЗаписьJSON = Новый ЗаписьJSON;
	лЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
	
	ЗаписатьJSON(лЗаписьJSON, Структура);
	
	Возврат лЗаписьJSON.Закрыть();
КонецФункции


Функция СтруктураИзJSON(СтрокаJSON, ПрочитатьВСоответсвие = Ложь) Экспорт
	лЧтениеJSON = Новый ЧтениеJSON;
	лЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	
	Возврат ПрочитатьJSON(лЧтениеJSON, ПрочитатьВСоответсвие);
КонецФункции


Функция РазбитьСтроку(Знач Строка, Разделитель = ",", СокрЛП = Истина, ПропускатьПустые = Ложь) Экспорт
	лСтрокаДлина = СтрДлина(Строка);
	лРазделительДлина  = СтрДлина(Разделитель);
	
	лМас = Новый Массив;
	Пока Истина Цикл
		лЛевДлина = Найти(Строка, Разделитель) - 1;
		Если лЛевДлина = -1 Тогда
			лЛевДлина = лСтрокаДлина;
		КонецЕсли;
		лФрагмент = Лев(Строка, лЛевДлина);
		Если СокрЛП Тогда
			лФрагмент = СокрЛП(лФрагмент);
		КонецЕсли;
		Если ЗначениеЗаполнено(лФрагмент) ИЛИ НЕ ПропускатьПустые Тогда
			лМас.Добавить(лФрагмент);
		КонецЕсли;
		Если лЛевДлина = лСтрокаДлина Тогда
			Возврат лМас;
		Иначе
			Строка = Сред(Строка, лЛевДлина + лРазделительДлина + 1);
			лСтрокаДлина = лСтрокаДлина - лЛевДлина - лРазделительДлина;
		КонецЕсли;
	КонецЦикла;
КонецФункции


Функция СоединитьСтроку(Массив, Разделитель = ",") Экспорт
	лПотокВПамяти = Новый ПотокВПамяти;
	
	лЗаписьТекста = Новый ЗаписьТекста(лПотокВПамяти, , Разделитель);
	
	Для Каждого лТекСтрока Из Массив Цикл
		лЗаписьТекста.ЗаписатьСтроку(лТекСтрока);
	КонецЦикла;
	
	лЗаписьТекста.Закрыть();
	
	лПотокВПамяти.Перейти(0, ПозицияВПотоке.Начало);
	
	лЧтениеТекста = Новый ЧтениеТекста(лПотокВПамяти);
	лРезультат = лЧтениеТекста.Прочитать();
	лЧтениеТекста.Закрыть();
	
	// Обрезаем последний разделитель
	Возврат Лев(лРезультат, СтрДлина(лРезультат) - СтрДлина(Разделитель));
КонецФункции


Функция ФайловыйURL(Путь) Экспорт
	лФайл = Новый Файл(Путь);
	лПолныйПуть = лФайл.ПолноеИмя;

	лПолныйПуть = СтрЗаменить(лПолныйПуть, "\", "/");
	лПолныйПуть = КодироватьСтроку(лПолныйПуть, СпособКодированияСтроки.URLВКодировкеURL);
	Если Сред(лПолныйПуть, 2, 1) = ":" Тогда
		Возврат "file:///" + лПолныйПуть; // Путь типа C:\file.txt
	Иначе
		Возврат "file://" + лПолныйПуть; // Путь типа \\SERVER\share\file.txt
	КонецЕсли;
КонецФункции


Функция ФорматВремя(Знач Время) Экспорт
	лСекунд = Время % 60;
	Время = (Время - лСекунд) / 60;
	лМинут = Время % 60;
	лЧасов = (Время - лМинут) / 60;
	Возврат Формат(лЧасов, "ЧН=; ЧВН=") + ":" + Формат(лМинут, "ЧЦ=2; ЧН=; ЧВН=") + ":" + Формат(лСекунд, "ЧЦ=2; ЧН=; ЧВН=");
КонецФункции


Процедура ПоменятьСтрокиМестами(Таблица, СтрокаА, СтрокаБ) Экспорт
	Если СтрокаА = СтрокаБ Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(Таблица) <> Тип("Массив") Тогда
		лИдА = Таблица.Индекс(СтрокаА);
		лИдБ = Таблица.Индекс(СтрокаБ);
		
		Таблица.Сдвинуть(СтрокаБ, лИдА - лИдБ);
		Таблица.Сдвинуть(СтрокаА, лИдБ - лИдА + ?(лИдБ > лИдА, -1, 1));
	Иначе
		лИдА = Таблица.Найти(СтрокаА);
		лИдБ = Таблица.Найти(СтрокаБ);
		
		Таблица[лИдБ] = СтрокаА;
		Таблица[лИдА] = СтрокаБ;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти
